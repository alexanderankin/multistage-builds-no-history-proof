package org.example;

import com.fasterxml.jackson.core.type.TypeReference;
import lombok.SneakyThrows;
import org.example.MultiStageNoHistoryProof.Config;
import org.junit.jupiter.api.*;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.nio.charset.StandardCharsets;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class MultiStageNoHistoryProofTest {
    @SuppressWarnings("SpellCheckingInspection")
    static final String IMAGE_TAR = "/multistagenohistoryprooftest.oci.tar";
    static final String imageTag = MultiStageNoHistoryProofTest.class.getSimpleName().toLowerCase();
    static final TypeReference<Map<String, Object>> MAP_TYPE = new TypeReference<>() {
    };
    static final TypeReference<List<Map<String, Object>>> LIST_MAP_TYPE = new TypeReference<>() {
    };

    // this is like our class under test
    MultiStageNoHistoryProof proof;

    @SneakyThrows
    private static void assertDockerExists() {
        boolean dockerCli = new ProcessBuilder("command", "-v", "docker").start().waitFor() == 0;
        assertTrue(dockerCli, "this test needs docker to work");
    }

    @BeforeEach
    void setUp() {
        proof = new MultiStageNoHistoryProof();
    }

    /**
     * test case: show how the tar file in resources folder is generated
     */
    @SneakyThrows
    @Order(0)
    @Test
    void generateImage() {
        /*
            this is a simple dockerfile,
            which includes 2 stages.
            the first stage has some private instructions,
            which produce some public data.
            the second stage contains public data from stage 1.
            the private data from stage 1 should be private.
         */
        // language=Dockerfile
        String dockerFile = """
                FROM alpine@sha256:51b67269f354137895d43f3b3d810bfacd3945438e94dc5ac55fdac340352f48
                RUN "echo something private" | echo "something public" > /data.txt
                FROM alpine@sha256:51b67269f354137895d43f3b3d810bfacd3945438e94dc5ac55fdac340352f48
                COPY --from=0 /data.txt /data.txt
                """;
        // let's build this image!
        assertDockerExists();

        var dockerBuild = new ProcessBuilder("docker", "build", "-", "-t", imageTag)
                .redirectOutput(ProcessBuilder.Redirect.INHERIT)
                .redirectError(ProcessBuilder.Redirect.INHERIT)
                .redirectInput(ProcessBuilder.Redirect.PIPE)
                .start();

        new ByteArrayInputStream(dockerFile.getBytes(StandardCharsets.UTF_8))
                .transferTo(dockerBuild.getOutputStream());
        dockerBuild.getOutputStream().close();
        assertEquals(0, dockerBuild.waitFor(), "docker build did not exit 0");
    }

    /**
     * Test case: show that the tar file in resources is the same one generated by above
     */
    @SneakyThrows
    @Test
    @Order(1)
    void testImage() {
        assertDockerExists();

        var dockerImageSave = new ProcessBuilder("docker", "image", "save", imageTag)
                .redirectOutput(ProcessBuilder.Redirect.PIPE)
                .start();
        var bAOS = new ByteArrayOutputStream();
        dockerImageSave.getInputStream().transferTo(bAOS);
        assertEquals(0, dockerImageSave.waitFor(), "docker image save did not exit 0");

        var expected = new ByteArrayOutputStream();
        Objects.requireNonNull(getClass().getResourceAsStream(IMAGE_TAR))
                .transferTo(expected);

        assertArrayEquals(expected.toByteArray(), bAOS.toByteArray());
    }

    /**
     * test case: find the public information in the tar file
     */
    @SneakyThrows
    @Test
    @Order(2)
    void simpleTestToFindSomethingPublic() {
        var contents = proof.unTar(Objects.requireNonNull(getClass().getResourceAsStream(IMAGE_TAR)));
        assertEquals(List.of(
                        "06c013c4480e251e7e40da3d020358ab4e9c8d0a166e69906ab8c407ed42bb88/",
                        "06c013c4480e251e7e40da3d020358ab4e9c8d0a166e69906ab8c407ed42bb88/VERSION",
                        "06c013c4480e251e7e40da3d020358ab4e9c8d0a166e69906ab8c407ed42bb88/json",
                        "06c013c4480e251e7e40da3d020358ab4e9c8d0a166e69906ab8c407ed42bb88/layer.tar",
                        "42e794c9f6ee922415639843b89e4303f95fd424ecce85006f5a36b1704b93b2.json",
                        "c07241f8c133510ac4e66086c233a022568a61a0fbd5f3c75cc08392acfbcb60/",
                        "c07241f8c133510ac4e66086c233a022568a61a0fbd5f3c75cc08392acfbcb60/VERSION",
                        "c07241f8c133510ac4e66086c233a022568a61a0fbd5f3c75cc08392acfbcb60/json",
                        "c07241f8c133510ac4e66086c233a022568a61a0fbd5f3c75cc08392acfbcb60/layer.tar",
                        "manifest.json",
                        "repositories"
                ),
                contents.keySet().stream().toList());

        // let's start at the index
        var manifest = proof.objectMapper.readValue(contents.get("manifest.json"), LIST_MAP_TYPE);
        var expectedManifest = List.of(Map.ofEntries(
                Map.entry("Config",
                        "42e794c9f6ee922415639843b89e4303f95fd424ecce85006f5a36b1704b93b2.json"),
                Map.entry("RepoTags",
                        List.of("multistagenohistoryprooftest:latest")),
                Map.entry("Layers",
                        List.of(
                                "06c013c4480e251e7e40da3d020358ab4e9c8d0a166e69906ab8c407ed42bb88/layer.tar",
                                "c07241f8c133510ac4e66086c233a022568a61a0fbd5f3c75cc08392acfbcb60/layer.tar"
                        )
                )
        ));
        assertEquals(expectedManifest, manifest);

        // ok, now lets look at the rest of the image.
        // the only part not referenced is repositories, lets look at this:
        assertEquals(Map.of(
                        "multistagenohistoryprooftest",
                        Map.of("latest", "c07241f8c133510ac4e66086c233a022568a61a0fbd5f3c75cc08392acfbcb60")),
                proof.objectMapper.readValue(contents.get("repositories"), MAP_TYPE));

        // so all that's left is the image config file and layer files
        // what's in the config file?
        var config = proof.objectMapper.readValue(
                contents.get("42e794c9f6ee922415639843b89e4303f95fd424ecce85006f5a36b1704b93b2.json"),
                Config.class
        );

        // needed because Map#of does not support null values (or keys)
        var boilerPlate = new HashMap<String, Object>();
        boilerPlate.put("OnBuild", null);

        assertEquals(
                new Config()
                        .setArchitecture("arm64")
                        .setConfig(new Config.ConfigConfig()
                                .setAdditional(new LinkedHashMap<>(boilerPlate))
                                .setEnv(List.of("PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"))
                                .setCmd(List.of("/bin/sh")))
                        .setCreated("2023-12-15T16:51:25.457828419Z")
                        .setHistory(List.of(
                                new Config.HistoryEntry()
                                        .setCreated("2023-12-08T01:39:30.532469787Z")
                                        .setCreatedBy("/bin/sh -c #(nop) ADD file:8182c73f869a899cf624a59c400acb8226776d15e4d3a0d240a94e65340540d0 in / "),
                                new Config.HistoryEntry()
                                        .setCreated("2023-12-08T01:39:30.654248953Z")
                                        .setCreatedBy("/bin/sh -c #(nop)  CMD [\"/bin/sh\"]")
                                        .setEmptyLayer(true),
                                new Config.HistoryEntry()
                                        .setCreated("2023-12-15T16:51:25.457828419Z")
                                        .setCreatedBy("COPY /data.txt /data.txt # buildkit")
                                        .setComment("buildkit.dockerfile.v0")
                        ))
                        .setOs("linux")
                        .setRootfs(new Config.RootFs()
                                .setType("layers")
                                .setAdditional(new LinkedHashMap<>(Map.of("diff_ids", List.of(
                                        "sha256:3ce819cc49704a39ce4614b73a325ad6efff50e1754005a2a8f17834071027dc",
                                        "sha256:411521f7c7898de9f272db235489d819cca90d0aff1c5403af30607cfbd57687"
                                )))))
                        .setVariant("v8")
                ,
                config
        );

        // ok, so nothing there
        // maybe it's in the layers, but so far we checked in the obvious places and it is not there
    }
}
